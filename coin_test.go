package main

import (
	"bytes"
	"encoding/binary"
	"log"
	"testing"
)

func TestValidVersionPayload(t *testing.T) {
	t.Skip()
	/*
		The following annotated hexdump shows a version message.
		(The message header has been omitted and the actual IP addresses have been replaced with RFC5737 reserved IP addresses.)

		72110100 ........................... Protocol version: 70002
		0100000000000000 ................... Services: NODE_NETWORK
		bc8f5e5400000000 ................... Epoch time: 1415483324

		0100000000000000 ................... Receiving node's services
		00000000000000000000ffffc61b6409 ... Receiving node's IPv6 address
		208d ............................... Receiving node's port number

		0100000000000000 ................... Transmitting node's services
		00000000000000000000ffffcb0071c0 ... Transmitting node's IPv6 address
		208d ............................... Transmitting node's port number

		128035cbc97953f8 ................... Nonce

		0f ................................. Bytes in user agent string: 15
		2f5361746f7368693a302e392e332f ..... User agent: /Satoshi:0.9.3/

		cf050500 ........................... Start height: 329167
		01 ................................. Relay flag: true

		0x72,0x11,0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xbc,0x8f,0x5e,0x54,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xc6,0x1b,0x64,0x09,0x20,0x8d,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xcb,0x00,0x71,0xc0,0x20,0x8d,0x12,0x80,0x35,0xcb,0xc9,0x79,0x53,0xf8,0f2f5361746f7368693a302e392e332fcf05050001

	*/

	knownGood := []byte{0x72, 0x11, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc, 0x8f, 0x5e, 0x54, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc6, 0x1b, 0x64, 0x09, 0x20, 0x8d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xcb, 0x00, 0x71, 0xc0, 0x20, 0x8d, 0x12, 0x80, 0x35, 0xcb, 0xc9, 0x79, 0x53, 0xf8, 0x0f, 0x2f, 0x53, 0x61, 0x74, 0x6f, 0x73, 0x68, 0x69, 0x3a, 0x30, 0x2e, 0x39, 0x2e, 0x33, 0x2f, 0xcf, 0x05, 0x05, 0x00, 0x01}

	v := VersionPayload{
		Version:           70002,
		Services:          binary.LittleEndian.Uint64([]byte{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}),
		Timestamp:         int64(1415483324),
		AddrRecvServices:  binary.LittleEndian.Uint64([]byte{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}),
		AddrRecvIP:        [16]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc6, 0x1b, 0x64, 0x09},
		AddrRecvPort:      binary.BigEndian.Uint16([]byte{0x20, 0x8d}),
		AddrTransServices: binary.LittleEndian.Uint64([]byte{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}),
		AddrTransIP:       [16]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xcb, 0x00, 0x71, 0xc0},
		AddrTransPort:     binary.BigEndian.Uint16([]byte{0x20, 0x8d}),
		Nonce:             binary.LittleEndian.Uint64([]byte{0x12, 0x80, 0x35, 0xcb, 0xc9, 0x79, 0x53, 0xf8}),
		UserAgentBytes:    uint8(15),
		UserAgent:         "/Satoshi:0.9.3/",
		StartHeight:       329167,
		Relay:             true,
	}

	versionBytes := v.encode()

	t.Logf("Encoded: %x", versionBytes)

	t.Logf("Good   : %x", knownGood)

	if !bytes.Equal(versionBytes, knownGood) {
		t.Log("Version payload format incorrect")
		t.Fail()
	}

}

func TestPeerDiscovery(t *testing.T) {
	t.Skip()

	peers, err := discoverPeers()
	if err != nil {
		t.Fatalf("DiscoverPeers returned error: %s", err.Error())
	}

	if len(peers) == 0 {
		t.Fatal("Got zero peers. Expecting more.")
	} else {
		t.Logf("Peer discovery returned %d peers. Peer 1 IP: %s", len(peers), peers[0].IP)
	}

}

func TestPeerConnection(t *testing.T) {
	t.Skip()

	peers, err := discoverPeers()
	if err != nil {
		t.Fatalf("DiscoverPeers returned error: %s", err.Error())
	}

	for _, peer := range peers {
		err := sendVersionMessage(peer.IP)
		if err != nil {
			//t.Logf("Failed to sendVersionMessage: %s", err.Error())
			continue
		}

	}

}

func TestDecodeInvMessage(t *testing.T) {

	buf := []byte{0xf9, 0xbe, 0xb4, 0xd9, 0x72, 0x65, 0x6a, 0x65, 0x63, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 0x7c, 0x59, 0x41, 0xa4, 0x09, 0x67, 0x65, 0x74, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x01, 0x29, 0x41, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x70, 0x72, 0x65, 0x63, 0x65, 0x64, 0x65, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x73, 0xf9, 0xbe, 0xb4, 0xd9, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x71, 0x00, 0x00, 0x00, 0x85, 0x55, 0xe3, 0x53, 0x7d, 0x11, 0x01, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xee, 0x8d, 0x5b, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x3f, 0xe2, 0x90, 0xfe, 0xe6, 0x75, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0xcf, 0x8e, 0xe7, 0x70, 0x13, 0x7c, 0x5b, 0x1b, 0x2f, 0x62, 0x74, 0x63, 0x77, 0x69, 0x72, 0x65, 0x3a, 0x30, 0x2e, 0x35, 0x2e, 0x30, 0x2f, 0x62, 0x74, 0x63, 0x64, 0x3a, 0x30, 0x2e, 0x31, 0x32, 0x2e, 0x30, 0x2f, 0xdd, 0x3c, 0x08, 0x00, 0x01, 0xf9, 0xbe, 0xb4, 0xd9, 0x76, 0x65, 0x72, 0x61, 0x63, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d, 0xf6, 0xe0, 0xe2}

	command := bytesToCommand(buf[4:16])

	log.Printf("Command: %s", command)

	if command == "reject" {
		rej := decodeRejectMessage(buf[23:])
		log.Printf("Rejected: %#v", rej)
	} else {
		things, err := decodeInvMessage(buf[4:])
		if err != nil {
			log.Print(err)
		}

		log.Printf("Things: %#v", things)
	}

}
